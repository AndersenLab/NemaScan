---
title: "NemaScan Report for TRAIT_NAME_HOLDER"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 5
    toc_float:
      collapsed: true
      smooth_scroll: true
---

<br>

## Usage

* All strain names were converted to the corresponding isotype name, which can be looked up here: https://www.elegansvariation.org/strain/strain_data.tsv
* This R Markdown file imports data tables within Analysis_Results-Date folder and will knit without any modification.
<br>
* Features for the interactive plots: 
    * Place mouse on plot region to show underlying data.
    * Click and drag to select a region to zoom, double click to reset zoom.
    * Click on the legend to show/hide different data groups.
<br>
* ggsave code is kept for users to make customized plots. 
<br>
<br>
<br>


```{r global_options, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
```



```{r include=FALSE}
library.path <- .libPaths()
library("tidyverse", lib.loc = library.path)
library("plotly", lib.loc = library.path)
library("DT", lib.loc = library.path)
library("ggbeeswarm", lib.loc = library.path)

```



```{r}
# load trait name
# in nextflow use sed to edit this field and make a copy of the .rmd for each trait
trait_name <- "TRAIT_NAME_HOLDER"   

# load independent tests result
total_independent_tests <- read.table("Genotype_Matrix/total_independent_tests.txt", quote="\"", comment.char="", stringsAsFactors=FALSE)

independent_test_cutoff <- -log10(0.05/total_independent_tests[[1]])

```


## Manhatton plot
* #### Every dot is a SNV marker.

* #### SNVs are colored red if they pass the genome-wide corrected significance threshold:
    * If Bonferroni-corrected significance (BF) threshold were used: the horizontal solid line corresponds to BF threshold, and the horizontal dash line corresponds to EIGEN threshold (see below). If user supplied threshold exists, it will replace the BF threshold.
    * If Eigen-decomposition significance threshold were used, the horizontal solid line overlaps with the dash line and corresponds to the EIGEN threshold, which corrects for the number of independent markers in your data set.

* #### Light blue regions are QTL confidence intervals. These regions have separate report pages with links below.


```{r, fig.height=3.5, fig.width=12}
# load processed mapping data. 
# Note that readr::read_delim will throw parsing errors and put NA in rows that contain actual values in strain/value/allele/var.exp so did not use it
processed_mapping <- read.delim(paste0("Mapping/Processed/processed_",trait_name,"_AGGREGATE_mapping.tsv"), stringsAsFactors=FALSE) %>%
    dplyr::mutate(CHROM = factor(CHROM, levels = c("I","II","III","IV","V","X","MtDNA"))) %>%
    dplyr::select(-marker) %>%
    tidyr::unite("marker", CHROM, POS, sep = ":", remove = F)

# each trait has a separate processed_mapping file now. So the plotting function and loop is removed
# but do check there is only 1 trait and if not, issue warning:
num_traits = length(unique(dplyr::select(processed_mapping,trait)))

if(num_traits > 1){
    print("WARNING: More than 1 trait in processed_mapping table. Only the first one will be plotted.")
}


## MANHATTAN PLOTS ##
BF.frame <- processed_mapping %>%
    dplyr::select(trait, BF) %>%
    dplyr::filter(!duplicated(trait))
for.plot <- processed_mapping %>%
    dplyr::mutate(CHROM = as.factor(CHROM)) %>%
    dplyr::filter(CHROM != "MtDNA") %>%
    dplyr::mutate(algorithm = as.factor(algorithm))
  
man.plot <- ggplot2::ggplot() + 
    ggplot2::theme_bw() + 
    ggplot2::geom_point(data = for.plot[which(for.plot$aboveBF == 1),], 
                        mapping = aes(x = POS/1000000, 
                                      y = log10p,
                                      fill = algorithm), shape = 21) +
    ggplot2::scale_fill_manual(values = c("blue","red"), name = "Algorithm") + 
    ggplot2::geom_point(data = for.plot[which(for.plot$aboveBF == 0),], 
                        mapping = aes(x = POS/1000000, 
                                      y = log10p), 
                        alpha = 0.25) +
    ggplot2::scale_y_continuous(expand = c(0,0), limits = c(0,max(for.plot$log10p + 1))) +
    ggplot2::geom_hline(data = BF.frame, aes(yintercept = BF), linetype = 2) + 
    ggplot2::labs(x = "Genomic position (Mb)",
                  y = expression(-log[10](italic(p)))) +
    ggplot2::theme(legend.position = "bottom", 
                   panel.grid = element_blank()) + 
    ggplot2::facet_grid(. ~ CHROM, scales = "free_x", space = "free") + 
    ggplot2::ggtitle(BF.frame$trait)

# save the plot to file. keep this code for user to create plots with their own styles
# ggsave(man.plot, filename = paste0(BF.frame$trait,"_manhattan.plot.png"), width = 8, height = 4)


# show plot in html output
man.plot
```



```{r}
# read in QTL regions for all traits. Note that QTL_peaks.tsv is generated even if there is no significant regions.
# based on number of regions & width of regions to decide whether generate pxg and fine mapping plots

# what happens to this file if no QTL?
if (file.info("Mapping/Processed/QTL_peaks.tsv")$size != 0) {

    whether_print_peaks <- TRUE
        
    QTL_peaks <- read.delim("Mapping/Processed/QTL_peaks.tsv", header=TRUE, stringsAsFactors=FALSE) %>%
        dplyr::filter(trait == trait_name)
    
    # don't have LD yet
    # if (nrow(QTL_peaks) < 2) { 
    #     whether_plot_LD <- FALSE 
    # } else { whether_plot_LD <- TRUE }
    
    if (nrow(QTL_peaks) == 0) {
        print("No significant QTL region for this trait")
        whether_fine_map <- FALSE # skip related chunks
        whether_plot_LD <- FALSE
    } else {

        QTL_peaks <- QTL_peaks %>%
            dplyr::mutate(Region_width = endPOS - startPOS) %>% 
            dplyr::filter(Region_width < 1500000)
        
        if (nrow(QTL_peaks)==0) {
            print("Significant QTL regions are too wide for plotting")
            whether_fine_map <- FALSE # skip related chunks
            
        } else {
            whether_fine_map <- TRUE # run related chunks
            
        }
    }
    
} else { 
    print("No significant peak for this trait")
    whether_print_peaks <- FALSE
    whether_plot_LD <- FALSE
    whether_fine_map <- FALSE
}

# don't have fine mapping yet...
whether_fine_map <- FALSE # skip related chunks
whether_plot_LD <- FALSE
```


```{r, eval=whether_print_peaks}
# print out the table to html
# this doesn't print within if{}
# QTL_peaks was filtered in previous chunk, so reload
QTL_peaks_original <- read.delim("Mapping/Processed/QTL_peaks.tsv", header=TRUE, stringsAsFactors=FALSE) %>% 
        dplyr::filter(trait == trait_name)

DT::datatable(QTL_peaks_original)

```

<br>
<br>

## Phenotype by Genotype Split
```{r, eval=whether_print_peaks}

pxg.plots <- function(trait, data){
  
}

## SWEPTNESS & EFFECTS SUMMARY ##
# proc.sweeps <- sweeps %>%
#     dplyr::select(c(isotype,contains("hapshare")))
# colnames(proc.sweeps) <- gsub(colnames(proc.sweeps),pattern = "_hapshare", replacement = "")
# sweep.chrom.pivot <- proc.sweeps %>%
#     tidyr::pivot_longer(cols = -isotype, names_to = "CHROM", values_to = "sweep.share") %>%
#     dplyr::rename(strain = isotype)




nested.pxg.dat <- processed_mapping %>%
    dplyr::filter(!is.na(peak_id)) %>%
    dplyr::select(CHROM, marker, trait, startPOS, peakPOS, endPOS, AF1, value, strain, allele, peak_id) %>%
    dplyr::distinct() %>%
    dplyr::mutate(startPOS = startPOS/1000000,
                  peakPOS = peakPOS/1000000,
                  endPOS = endPOS/1000000) %>%
    # dplyr::left_join(.,sweep.chrom.pivot) %>% # don't have this file yet
    # dplyr::group_by(trait, peak_id) %>%
    # dplyr::recode(allele, "-1" = "REF", "1" = "ALT") %>%
    dplyr::mutate(allele = dplyr::case_when(allele == "-1" ~ "REF",
                                            allele == "1" ~ "ALT",
                                            TRUE ~ "NA"),
                  allele = factor(allele, levels = c("REF", "ALT")))
    
CB.N2.code <- nested.pxg.dat %>%
    dplyr::select(strain, allele) %>%
    dplyr::distinct() %>%
    dplyr::filter(strain %in% c("CB4856","N2","PD1074")) %>%
    droplevels()
    
if(length(levels(CB.N2.code$allele)) < 2){
  pal <- c("#726E75","#720E07")
} else {
  pal <- c("#FFA500","#0000ff")
}

plot_title <- glue::glue("{unique(nested.pxg.dat$trait)}:CHR{unique(nested.pxg.dat$CHROM)}:{round(unique(nested.pxg.dat$peakPOS), digits = 2)}MB")

plot <- nested.pxg.dat %>%
    dplyr::filter(allele != "NA" | !is.na(allele)) %>%
    droplevels() %>%
    ggplot2::ggplot(mapping = aes(x = allele, y = value)) +
    ggplot2::theme_bw(base_size = 12) +
    ggplot2::geom_violin(aes(fill = allele), alpha = 0.8, scale = "count", draw_quantiles = c(0.25, 0.5, 0.75)) +
    ggplot2::scale_fill_manual(values = pal, guide = FALSE) +
    ggbeeswarm::geom_beeswarm(size = 1.1) + 
    # ggbeeswarm::geom_beeswarm(aes(colour = sweep.share*100), size = 1.1) + 
    ggrepel::geom_text_repel(data = nested.pxg.dat[which(nested.pxg.dat$strain %in% c("N2","CB4856")),], aes(label = strain), colour = "black", 
                  box.padding = 1, point.padding = 0.1) + 
    # ggplot2::scale_colour_gradient(low = "black", high = "violetred", name = "Selective Sweep (% Chromosome)") +
    ggplot2::theme(legend.position = "bottom") +
    # ggplot2::ggtitle(paste(unique(nested.pxg.dat$trait), paste("CHR",unique(nested.pxg.dat$CHROM), sep = ""),
                # paste(round(unique(nested.pxg.dat$peakPOS), digits = 2),"MB", sep = ""), sep = ": ")) +
    ggplot2::labs(y = "Trait Value", 
                  x = "Genotype", 
                  title = plot_title)

print(plot)

# ggsave(glue::glue("{plot_title}_effect.plot.png"), height = 5, width = 5)


```

## Divergent region, haplotype, and fine mapping for each significant QTL region 
Only for regions less than 1.5Mb in size

```{r, results='asis', eval=whether_fine_map}
link_list <- list()

for (i in seq_len(nrow(QTL_peaks))) { 
    
    region_name <- glue::glue("{QTL_peaks$CHROM[i]}:{QTL_peaks$startPOS[i]}-{QTL_peaks$endPOS[i]}")
    link_list[i] <- glue::glue("[{region_name}](cegwas2_report_TRAIT_NAME_HOLDER_region_{region_name}.html)")

}

for (l in link_list) {
    cat("\n##", l, "\n")
    cat("  \n")
}
```

```{r, eval=!whether_fine_map}
print("No significant QTL regions to plot")
```

<br>
<br>


## Please kindly cite the following publications
* Cook, D.E., Zdraljevic, S., Roberts, J.P., and Andersen, E.C. (2016). CeNDR, the Caenorhabditis elegans natural diversity resource. Nucleic Acids Res.
* Zdraljevic, S., Fox, B.W., Strand, C., Panda, O., Tenjo, F.J., Brady, S.C., Crombie, T.A., Doench, J.G., Schroeder, F.C., and Andersen, E.C. (2019). Natural variation in C. elegans arsenic toxicity is explained by differences in branched chain amino acid metabolism. Elife 8.
* Lee, D., Zdraljevic, S., Stevens, L., Wang, Y., Tanny, R.E., Crombie, T.A., Cook, D.E., Webster, A.K., Chirakar, R., Ryan Baugh, L., et al. (2020). Balancing selection maintains ancient genetic diversity in C. elegans.
* haplotype paper

<br>
<br>

```{r}
sessionInfo()
```
