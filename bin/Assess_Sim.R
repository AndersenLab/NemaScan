require(tidyverse)
require(data.table)
require(GenomicRanges)

#############
# ARGUMENTS #
#############

args <- commandArgs(trailingOnly = TRUE)
#Args
# 1. Path to mapping object
# 2. path to genotype_matrix
# 3. path to variant effect file sims.par
# 4. path to the phenotype file sims.phen
# 5. nQTL 
# 6. simREP
# 7. h2
# 8. maf
# 9. effect_distribution
# 10. strain_set_id
# 11. algorithm_id

effects <- data.table::fread(
    args[3],
    header = TRUE
    )%>%
    tidyr::separate(QTL, c("CHROM","POS"), sep = ":", remove = F)

phenos <- data.table::fread(
    args[4],
    header = FALSE,
    col.names = c("strain", "strain2", "trait.value")
)%>%
    dplyr::select(-strain2)

complete.effects <- data.table::fread(
    args[2],
    header = T) %>%
      tidyr::unite("QTL",c(CHROM, POS), sep = ":", remove = F) %>%
      dplyr::filter(QTL %in% effects$QTL) %>% #Filter markers in the GM that are causal variants
      dplyr::select(-CHROM, -POS) %>% #Get rid of the CHOM and POS columns
      tidyr::pivot_longer(cols = !c(QTL, REF, ALT), names_to = "strain", values_to = "allele") %>%
      dplyr::full_join(.,effects) %>%
      dplyr::full_join(.,phenos) %>%
      dplyr::group_by(QTL) %>%
      dplyr::summarise(n = n()) %>%
      dplyr::filter(n != 1,
                    !is.na(QTL))


genos.effects <- data.table::fread(args[2], header = TRUE) %>%
    tidyr::unite("QTL",c(CHROM, POS), sep = ":", remove = F) %>%
    dplyr::filter(QTL %in% effects$QTL) %>%
    dplyr::select(-CHROM, -POS) %>%
    tidyr::pivot_longer(cols = !c(QTL, REF, ALT), names_to = "strain", values_to = "allele") %>%
    dplyr::full_join(.,effects) %>%
    dplyr::full_join(.,phenos) %>%
    dplyr::group_by(QTL) %>%
    tidyr::nest()


#Not sure what this really is for? Sam's script uses it, if there is not an 
#equal number of rows in the genotype matrix the the genos.effects data 
#is generated by the full effects file. 
#If there are not an equal

# Simulated Variance Explained
var.exp <- function(data,QTL){
    aov.out <- summary(aov(data = data, trait.value ~ allele + 1))
    SST <- sum(aov.out[[1]][[2]])
    SSallele <- aov.out[[1]][[2]][[1]]
    simulated.variance.exp <- SSallele/SST
    data.frame(QTL, simulated.variance.exp)
}

#Calculate the variance explained for each QTL based on the strains and phenotyes
simQTL.variance.explained <- purrr::map2(genos.effects$data, 
                                        genos.effects$QTL, 
                                        var.exp) %>%
    Reduce(rbind,.)

#Add the simulated variance explained to the list of simulated causal variants
effects <- effects %>%
    dplyr::full_join(.,simQTL.variance.explained) %>%
    dplyr::rename(Simulated.QTL.VarExp = simulated.variance.exp)

#Load the mapping data

map_obj <- data.table::fread(
    args[1],
    header = TRUE
    ) 


##Process the mapping results

#Filter the mapping results to just peaks
peak.info <- map_obj %>%
    dplyr::filter(!is.na(peak_id)) %>% #remove the non-significant peaks
    dplyr::select(CHROM, marker, POS, AF1, BETA, log10p, startPOS, peakPOS, endPOS, peak_id, interval_size, var.exp) %>%
    dplyr::filter(!duplicated(.)) %>%
    dplyr::mutate(detected.peak = marker)

#Score the detected QTL against the simulated QTL
simulated.mapping.results.scores <- map_obj %>%
    dplyr::rename(QTL = marker) %>%
    dplyr::filter(QTL %in% effects$QTL) %>%
    dplyr::select(QTL, log10p, aboveBF)


effects.scores <- effects  %>%
    dplyr::full_join(., simulated.mapping.results.scores) %>%
    dplyr::filter(
            !duplicated(QTL),
            !is.na(log10p)
        )
        
peaks <- GenomicRanges::GRanges(
            seqnames = peak.info$CHROM,
            ranges = IRanges::IRanges(
                                    start = peak.info$startPOS,
                                    end = peak.info$endPOS),
                                peakPOS = peak.info$peakPOS,
                                detected.peak = peak.info$detected.peak)
real.effects <- GenomicRanges::GRanges(
                                seqnames = effects.scores$CHROM,
                                ranges = IRanges::IRanges(
                                                    start = as.numeric(effects.scores$POS),
                                                    end = as.numeric(effects.scores$POS)),
                                QTL = effects.scores$QTL)
        
overlap <- IRanges::findOverlapPairs(
                        real.effects,
                        peaks
                    ) %>%
        as.data.frame() %>%
        dplyr::select(first.QTL, second.X.start, second.peakPOS, second.X.end, second.detected.peak) %>%
        `colnames<-`(c("QTL","startPOS","peakPOS","endPOS","detected.peak")) %>%
        dplyr::right_join(., peak.info) %>%
        dplyr::mutate(QTL = if_else(is.na(QTL),
                                    true = detected.peak,
                                    false = QTL)) %>%
        dplyr::rename(interval.log10p = log10p,
                    interval.var.exp = var.exp,
                    interval.Frequency = AF1) %>%
        dplyr::select(-c(CHROM, marker, POS))

all.QTL <- data.frame(c(effects.scores$QTL, overlap$QTL)) %>%
            `colnames<-`(c("QTL")) %>%
            dplyr::filter(!duplicated(QTL)) %>%
            dplyr::mutate(
                    QTL = as.character(QTL),
                    Simulated = (QTL %in% effects.scores$QTL),
                    Detected = (QTL %in% overlap$QTL)) %>%
            dplyr::full_join(.,effects.scores, by = "QTL") %>%
            dplyr::full_join(.,overlap, by = "QTL") %>%
            dplyr::mutate(
                        #algorithm = algorithm_id ,
                        top.hit = QTL == detected.peak,
                        nQTL = args[5],
                        simREP = args[6],
                        h2 = args[7],
                        maf = args[8],
                        effect_distribution = args[9],
                        strain_set_id = args[10],
                        algorithm_id = args[11]
                        #sim = x)
            )
         
all.QTL$Simulated <- factor(all.QTL$Simulated, levels = c("TRUE","FALSE"))
all.QTL$Detected <- factor(all.QTL$Detected, levels = c("TRUE","FALSE"))
         
algorithm <- args[11]
#Write outputfile
write.table(all.QTL, file = glue::glue("{algorithm}_all.QTL._mapping.tsv"), sep = "\t", row.names = F, quote = F, col.names = F)